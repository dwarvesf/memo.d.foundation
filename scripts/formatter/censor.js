/**
 * Usage: OPENAI_API_KEY=xxx node censor.js /path/to/dir
 *
 * Set the OPENAI_API_KEY environment variable in your shell or prefix the command.
 *
 * This script processes markdown files containing internal project updates,
 * transforming specific project update sections into generalized summaries
 * for broader communication, while maintaining confidentiality and the original document's feel.
 */

import fs from 'fs/promises';
import path from 'path';
import matter from 'gray-matter';

const fetch =
  globalThis.fetch || (await import('node-fetch')).then(mod => mod.default);

const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
const OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';
const MODEL = 'gpt-4.1-mini';

if (!OPENAI_API_KEY) {
  console.error(
    'Error: OPENAI_API_KEY environment variable is not set. Set it in your shell or in a .env file.',
  );
  process.exit(1);
}

if (process.argv.length < 3) {
  console.error('Usage: OPENAI_API_KEY=xxx node censor.js /path/to/dir');
  process.exit(1);
}

const rootDir = process.argv[2];

// Prompt instructing the AI to transform internal project updates into generalized summaries
const PROMPT = `
You are an AI assistant processing internal memos. Your task is to:
1.  Identify and **completely remove** sections dedicated to updates across multiple distinct client projects (e.g., sections titled ### Project Updates listing progress for Client A, Client B, etc.).
2.  In the **remaining text**, redact specific names:
    * Replace **Client COMPANY Names** -> Generic descriptions (e.g., "a key client", "a partner").
    * Keep our engineers name as is (e.g., "Phat Nguyen", "Huy").
    * Keep "**Dwarves Foundation**" or related names as is.
3.  Preserve all other content, structure, and formatting.
4.  **Do not** use placeholders like "[Name]".

**Goal:** Output a revised memo ready for broader sharing, with specific project update sections removed and names redacted in the remaining content per the rules.
`;

async function findMarkdownFiles(dir) {
  let results = [];
  const entries = await fs.readdir(dir, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      results = results.concat(await findMarkdownFiles(fullPath));
    } else if (entry.isFile() && entry.name.endsWith('.md')) {
      results.push(fullPath);
    }
  }
  return results;
}

async function transformContentWithAI(content) {
  const response = await fetch(OPENAI_API_URL, {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${OPENAI_API_KEY}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      model: MODEL,
      messages: [
        { role: 'system', content: PROMPT },
        { role: 'user', content: content },
      ],
      max_tokens: 2000,
      temperature: 0.7,
    }),
  });

  if (!response.ok) {
    throw new Error(
      `OpenAI API error: ${response.status} ${response.statusText}`,
    );
  }

  const data = await response.json();
  const transformed = data.choices?.[0]?.message?.content?.trim();
  if (!transformed)
    throw new Error('No transformed content generated by OpenAI.');
  return transformed;
}

async function processFile(filePath) {
  let updated = false;
  let logMsg = '';
  try {
    const raw = await fs.readFile(filePath, 'utf8');
    const parsed = matter(raw);

    // Send the full content to AI for transformation
    const transformedContent = await transformContentWithAI(parsed.content);

    // Replace the content with transformed content, keep frontmatter intact
    const newRaw = matter.stringify(transformedContent, parsed.data);

    if (newRaw !== raw) {
      await fs.writeFile(filePath, newRaw, 'utf8');
      updated = true;
      logMsg = `✅ Updated: ${filePath}`;
    } else {
      logMsg = `⏩ Skipped (no changes): ${filePath}`;
    }
  } catch (err) {
    logMsg = `❌ Failed: ${filePath} - ${err.message}`;
  }
  console.log(logMsg);
  return { filePath, updated, logMsg };
}

async function main() {
  try {
    const files = await findMarkdownFiles(rootDir);
    if (files.length === 0) {
      console.log('No markdown files found.');
      return;
    }
    let updatedCount = 0;
    for (const file of files) {
      const result = await processFile(file);
      if (result.updated) updatedCount++;
    }
    console.log(
      `\nProcess completed. ${updatedCount} file(s) updated out of ${files.length}.`,
    );
  } catch (err) {
    console.error('Fatal error:', err);
    process.exit(1);
  }
}

main();
