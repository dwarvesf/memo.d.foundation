name: Generate Redirects

on:
  workflow_dispatch: # Keep manual trigger
  push:
    branches:
      - main
    paths:
      - 'db/vault.parquet'

concurrency:
  group: ${{ github.repository }}-workflow
  cancel-in-progress: false

env:
  VAULT_ADDR: ${{ secrets.VAULT_ADDR }}

jobs:
  generate-redirects:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout contents repo
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.DWARVES_PAT }}
          submodules: recursive
          fetch-depth: 0 # Fetch all history for git diff to work correctly

      - name: Install Vault CLI
        run: |
          rm -rf vault_1.15.5_linux_amd64.zip
          wget https://releases.hashicorp.com/vault/1.15.5/vault_1.15.5_linux_amd64.zip
          sudo unzip -o vault_1.15.5_linux_amd64.zip -d /usr/local/bin/

      - name: Authenticate with Vault AppRole
        run: |
          VAULT_TOKEN=$(vault write -field=token auth/approle/login \
            role_id="${{ secrets.VAULT_ROLE_ID }}" \
            secret_id="${{ secrets.VAULT_SECRET_ID }}")
          echo "VAULT_TOKEN=$VAULT_TOKEN" >> $GITHUB_ENV

      - name: Get changed files
        id: changed-files
        run: |
          # Install DuckDB
          wget -q https://github.com/duckdb/duckdb/releases/download/v1.0.0/duckdb_cli-linux-amd64.zip
          unzip -q duckdb_cli-linux-amd64.zip
          chmod +x duckdb

          echo "Collecting .md files changed in the latest commit and processing submodules conditionally."

          # Export this for subshells used by git submodule foreach
          export ALL_CHANGED_MD_FILES_ACCUMULATOR_PATH="/tmp/all_changed_md_files_accumulator.txt"
          rm -f "$ALL_CHANGED_MD_FILES_ACCUMULATOR_PATH" # Ensure it's clean
    
          # Get all files changed in the latest commit of the parent repository
          PARENT_CHANGED_FILES=$(git log --pretty=format: --name-only -n 1 ${{ github.sha }})
          echo "Files changed in parent repository's latest commit (SHA: ${{ github.sha }}):"
          echo "$PARENT_CHANGED_FILES"
    
          # Check if the 'vault' directory/submodule itself was affected in the parent's latest commit.
          # This is the condition for processing submodules for their .md changes.
          PROCESS_SUBMODULES_FOR_MD_FILES=false
          if echo "$PARENT_CHANGED_FILES" | grep -q "^vault"; then
            echo "'vault' (submodule or directory) was affected in the parent's latest commit. Will scan submodules for their recent .md changes."
            PROCESS_SUBMODULES_FOR_MD_FILES=true
          else
            echo "'vault' (submodule or directory) was NOT affected in the parent's latest commit. Submodules will not be scanned for their recent .md changes."
          fi
    
          if [ "$PROCESS_SUBMODULES_FOR_MD_FILES" = true ]; then
            echo "Processing submodules for their latest .md changes..."
            # The script block for foreach is single-quoted. Variables like $path, $name are expanded by foreach.
            # $ALL_CHANGED_MD_FILES_ACCUMULATOR_PATH is an env var and will be available.
            git submodule foreach --recursive '
              echo "Processing submodule: $name ($path)"
              if [ ! -e ".git" ]; then
                echo "Warning: $name at $path does not appear to be a git repository or submodule. Skipping."
                continue
              fi
    
              SUBMODULE_LATEST_COMMIT_SHA=$(git rev-parse HEAD)
              echo "Getting changed .md files from submodule $name''s latest commit (SHA: $SUBMODULE_LATEST_COMMIT_SHA)..."
              
              # Get .md files from the latest commit in the submodule
              SUBMODULE_MD_FILES=$(git log --pretty=format: --name-only -n 1 HEAD -- "*.md")
              
              if [ -n "$SUBMODULE_MD_FILES" ]; then
                # Prepend submodule path using awk and append to accumulator
                echo "$SUBMODULE_MD_FILES" | awk -v current_submodule_path="$path" "{print current_submodule_path \"/\" \$0}" >> "$ALL_CHANGED_MD_FILES_ACCUMULATOR_PATH"
              else
                echo "No .md files found in the latest commit of submodule $name."
              fi
            '
          fi
    
          CONSOLIDATED_MD_FILES=""
          if [ -f "$ALL_CHANGED_MD_FILES_ACCUMULATOR_PATH" ]; then
            # Sort, remove duplicates, filter out potential empty lines, then format as comma-separated
            # Ensure grep -v '^$' is used to remove empty lines that might result from `|| true` or empty submodule logs
            CONSOLIDATED_MD_FILES=$(sort "$ALL_CHANGED_MD_FILES_ACCUMULATOR_PATH" | uniq | grep -v '^$' | tr '\n' ',' | sed 's/,$//')
            rm "$ALL_CHANGED_MD_FILES_ACCUMULATOR_PATH"
          fi
    
          if [ -z "$CONSOLIDATED_MD_FILES" ]; then
            echo "No markdown files found in the latest commits of the parent or relevant submodules to process."
            echo "files=" >> $GITHUB_OUTPUT
            exit 0 
          fi
    
          echo "Markdown files from latest commits (parent & submodules): $CONSOLIDATED_MD_FILES"
          SQL_IN_LIST=$(echo "$CONSOLIDATED_MD_FILES" | awk -F, '{for(i=1;i<=NF;i++) printf (i==1 ? "" : "," ) "\047" $i "\047"}')
    
          if [ -z "$SQL_IN_LIST" ]; then
            echo "No markdown files to check against parquet after formatting for SQL."
            echo "files=" >> $GITHUB_OUTPUT
            exit 0
          fi
    
          DB_QUERY="SELECT file_path FROM 'db/vault.parquet' WHERE file_path IN ($SQL_IN_LIST) AND has_redirects = false;"
          echo "Executing DuckDB query: $DB_QUERY"
          
          FILES_TO_PROCESS_FROM_DB=$(./duckdb -list -noheader -c "$DB_QUERY" | tr '\n' ',' | sed 's/,$//')
    
          if [ -z "$FILES_TO_PROCESS_FROM_DB" ]; then
            echo "No files found in vault.parquet that match the criteria (are in the collected .md files list and have has_redirects = false)."
            echo "files=" >> $GITHUB_OUTPUT
            exit 0
          fi
    
          echo "Markdown files to process (from DB query): $FILES_TO_PROCESS_FROM_DB"
          echo "files=$FILES_TO_PROCESS_FROM_DB" >> $GITHUB_OUTPUT

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install --legacy-peer-deps gray-matter crypto js-yaml@4.1.0 tsx

      - name: Run script with files
        if: steps.changed-files.outputs.files != ''
        run: |
          npx tsx generate-redirects.ts --files='${{ steps.changed-files.outputs.files }}'

      - name: Commit and push changes
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"
          git checkout main || git checkout master || echo "WARN: Failed to checkout main or master in parent repository. Proceeding with current branch."
          # Process Level 1 submodules
          git submodule foreach '
            echo "Processing L1 submodule: $name ($path)"
            git checkout main || git checkout master || echo "WARN: Failed to checkout main/master in L1 submodule $name, attempting push on current state"
            git add --all
            git commit -m "chore(ci): redirects" || echo "INFO: No changes to commit in L1 submodule $name"
            git push || echo "WARN: Failed to push L1 submodule $name. Continuing..."

            # Process Level 2 submodules (submodules of the current L1 submodule)
            # This command is executed from within the L1 submodule directory
            # Wrapped in a subshell to catch errors from the inner foreach
            (git submodule foreach '\''
              echo "  Processing L2 submodule: $name ($path)"
              git checkout main || git checkout master || echo "  WARN: Failed to checkout main/master in L2 submodule $name, attempting push on current state"
              git add --all
              git commit -m "chore(ci): redirects" || echo "  INFO: No changes to commit in L2 submodule $name"
              git push || echo "  WARN: Failed to push L2 submodule $name. Continuing..."
            '\'' || echo "WARN: Inner foreach for L2 in L1 submodule $name ($path) encountered an issue. Continuing...")
          ' || echo "WARN: Outer foreach for L1 submodules encountered an issue. Attempting to process parent repo."
          # Commit and push changes in the parent repository
          git add --all
          git commit -m "chore(ci): redirects" || echo "INFO: No changes to commit in parent repository"
          git push || echo "WARN: Failed to push parent repository."
